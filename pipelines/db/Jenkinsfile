// ============================================================
// Emart Login Service - DB Team Jenkins Pipeline
// Mongock MongoDB Migrations: Dev -> Staging -> Production
// Team: DB Team
// ============================================================

pipeline {
    agent any

    environment {
        APP_NAME          = 'emart-login-backend'
        MONGO_URI_DEV     = credentials('mongo-uri-dev')
        MONGO_URI_STAGING = credentials('mongo-uri-staging')
        MONGO_URI_PROD    = credentials('mongo-uri-prod')
        SLACK_WEBHOOK     = credentials('slack-webhook')
    }

    parameters {
        choice(name: 'TARGET_ENV',
               choices: ['dev', 'staging', 'prod'],
               description: 'Target environment for migration')
        booleanParam(name: 'DRY_RUN',
                     defaultValue: true,
                     description: 'Preview changes without executing (always true for prod first run)')
        booleanParam(name: 'VERIFY_ONLY',
                     defaultValue: false,
                     description: 'Only verify migration status')
    }

    options {
        timeout(time: 30, unit: 'MINUTES')
        buildDiscarder(logRotator(numToKeepStr: '20'))
        timestamps()
        disableConcurrentBuilds()
    }

    stages {

        stage('Checkout') {
            steps {
                checkout scm
                script {
                    env.GIT_COMMIT_SHORT = sh(script: "git rev-parse --short HEAD", returnStdout: true).trim()
                }
            }
        }

        // ====================================================
        // DB VALIDATION: Verify migration scripts
        // ====================================================
        stage('Validate Migration Scripts') {
            steps {
                dir('backend') {
                    sh '''
                        echo "=== [DB] Validating Mongock migration scripts ==="

                        # Check migration naming convention (V001_, V002_, ...)
                        find src/main/java/com/emart/login/migration -name "*.java" | \
                            grep -v "^V[0-9]\\{3\\}_" | \
                            (grep -q . && echo "ERROR: Migration files must follow V###_ClassName.java naming" && exit 1) || true

                        # Check for duplicate migration IDs
                        grep -r "@ChangeUnit" src/main/java/com/emart/login/migration/ | \
                            grep -o 'id = "[^"]*"' | sort | uniq -d | \
                            (grep -q . && echo "ERROR: Duplicate migration IDs found!" && exit 1) || true

                        echo "Migration scripts validation PASSED"

                        # Compile to verify no syntax errors
                        mvn compile --batch-mode -q
                        echo "Compilation check PASSED"
                    '''
                }
            }
        }

        // ====================================================
        // MIGRATION STATUS CHECK
        // ====================================================
        stage('Check Migration Status') {
            steps {
                script {
                    def mongoUri = getMongoUri(params.TARGET_ENV)
                    sh """
                        echo "=== [DB] Checking current migration status on ${params.TARGET_ENV} ==="
                        
                        # Connect to MongoDB and check mongockChangeLog collection
                        mongosh "${mongoUri}" --eval "
                            db = db.getSiblingDB('userdb');
                            var changes = db.mongockChangeLog.find({}).toArray();
                            print('Total migrations applied: ' + changes.length);
                            changes.forEach(function(c) {
                                print('  [' + c.state + '] ' + c.changeId + ' - ' + c.author + ' - ' + c.timestamp);
                            });
                        " 2>/dev/null || echo "Could not check migration status (DB may not be initialized)"
                    """
                }
            }
        }

        // ====================================================
        // DRY RUN: Preview migration
        // ====================================================
        stage('Migration Dry Run') {
            when { expression { params.DRY_RUN } }
            steps {
                dir('backend') {
                    script {
                        def mongoUri = getMongoUri(params.TARGET_ENV)
                        sh """
                            echo "=== [DB] DRY RUN: Previewing Mongock migrations ==="
                            echo "Target: ${params.TARGET_ENV}"
                            echo "MongoDB: ${mongoUri.replaceAll(':[^@]*@', ':***@')}"
                            echo ""
                            echo "Pending migration scripts:"
                            find src/main/java/com/emart/login/migration -name "*.java" | sort
                            echo ""
                            echo "DRY RUN complete. Review above migrations before proceeding."
                        """
                    }
                }
            }
        }

        // ====================================================
        // BACKUP before migration (Staging & Prod)
        // ====================================================
        stage('Pre-Migration Backup') {
            when {
                anyOf {
                    expression { params.TARGET_ENV == 'staging' }
                    expression { params.TARGET_ENV == 'prod' }
                }
            }
            steps {
                script {
                    def mongoUri = getMongoUri(params.TARGET_ENV)
                    def backupDir = "/backup/emart/userdb-${params.TARGET_ENV}-${env.BUILD_NUMBER}-${new Date().format('yyyyMMdd-HHmmss')}"
                    sh """
                        echo "=== [DB] Creating pre-migration backup ==="
                        mkdir -p ${backupDir}
                        mongodump \
                            --uri="${mongoUri}" \
                            --db=userdb \
                            --out=${backupDir}
                        echo "Backup created at: ${backupDir}"
                        ls -la ${backupDir}
                    """
                    env.BACKUP_DIR = backupDir
                }
            }
        }

        // ====================================================
        // APPROVAL: Required for staging & prod
        // ====================================================
        stage('Migration Approval') {
            when {
                anyOf {
                    expression { params.TARGET_ENV == 'staging' }
                    expression { params.TARGET_ENV == 'prod' }
                }
            }
            steps {
                script {
                    emailext(
                        subject: "[EMART] DB Migration Approval Required - ${params.TARGET_ENV.toUpperCase()}",
                        body: """
                        Mongock migration ready for ${params.TARGET_ENV}.
                        Backup created at: ${env.BACKUP_DIR}
                        Approve: ${env.BUILD_URL}
                        """,
                        to: 'db-lead@emart.com,devops@emart.com'
                    )
                    timeout(time: 30, unit: 'MINUTES') {
                        input(
                            message: "Approve DB migration to ${params.TARGET_ENV.toUpperCase()}?",
                            ok: "Run Migration",
                            submitter: "db-lead,devops-team"
                        )
                    }
                }
            }
        }

        // ====================================================
        // EXECUTE MIGRATION via Spring Boot (Mongock auto-runs)
        // ====================================================
        stage('Execute Migration') {
            when { expression { !params.VERIFY_ONLY } }
            steps {
                dir('backend') {
                    script {
                        def mongoUri = getMongoUri(params.TARGET_ENV)
                        def springProfile = params.TARGET_ENV
                        sh """
                            echo "=== [DB] Running Mongock migrations on ${params.TARGET_ENV} ==="
                            
                            # Run as Spring Boot migration-only mode
                            # (Mongock runs on application startup)
                            MONGO_URI="${mongoUri}" \
                            SPRING_PROFILES_ACTIVE="${springProfile}" \
                            MONGOCK_ENABLED=true \
                            mvn spring-boot:run \
                                -Dspring-boot.run.arguments="--spring.main.web-application-type=none" \
                                --batch-mode \
                                -q &
                            
                            # Give migrations time to run then kill the process
                            SPRING_PID=\$!
                            sleep 30
                            kill \$SPRING_PID 2>/dev/null || true
                            
                            echo "Mongock migrations executed"
                        """
                    }
                }
            }
        }

        // ====================================================
        // VERIFY: Confirm migrations applied correctly
        // ====================================================
        stage('Verify Migration') {
            steps {
                script {
                    def mongoUri = getMongoUri(params.TARGET_ENV)
                    sh """
                        echo "=== [DB] Verifying migrations on ${params.TARGET_ENV} ==="
                        mongosh "${mongoUri}" --eval "
                            db = db.getSiblingDB('userdb');
                            
                            // 1. Verify mongockChangeLog
                            var changes = db.mongockChangeLog.find({state: 'EXECUTED'}).toArray();
                            print('Successfully applied migrations: ' + changes.length);
                            
                            // 2. Verify users collection exists
                            var collections = db.getCollectionNames();
                            if (!collections.includes('users')) {
                                print('ERROR: users collection not found!');
                                quit(1);
                            }
                            print('users collection: EXISTS');
                            
                            // 3. Verify indexes on users
                            var indexes = db.users.getIndexes();
                            print('Indexes on users collection:');
                            indexes.forEach(idx => print('  ' + idx.name + ': ' + JSON.stringify(idx.key)));
                            
                            // 4. Verify unique indexes
                            var emailIdx = indexes.find(i => i.name === 'idx_email_unique');
                            var phoneIdx = indexes.find(i => i.name === 'idx_phone_unique');
                            if (!emailIdx || !emailIdx.unique) { print('ERROR: email unique index missing!'); quit(1); }
                            if (!phoneIdx || !phoneIdx.unique) { print('ERROR: phone unique index missing!'); quit(1); }
                            
                            print('All verifications PASSED!');
                        "
                    """
                }
            }
        }
    }

    post {
        success {
            script {
                notifySlack("SUCCESS", "DB Migrations completed on ${params.TARGET_ENV}")
            }
        }
        failure {
            script {
                notifySlack("FAILED", "DB Migration FAILED on ${params.TARGET_ENV}! Backup at: ${env.BACKUP_DIR}")
                echo "=== MIGRATION FAILED - Manual rollback may be needed ==="
                echo "Backup location: ${env.BACKUP_DIR}"
                echo "Restore command: mongorestore --uri=<MONGO_URI> --dir=${env.BACKUP_DIR}"
            }
        }
    }
}

def getMongoUri(String env) {
    switch(env) {
        case 'dev':     return "${MONGO_URI_DEV}"
        case 'staging': return "${MONGO_URI_STAGING}"
        case 'prod':    return "${MONGO_URI_PROD}"
    }
}

def notifySlack(String status, String message) {
    def color = status == "SUCCESS" ? "good" : "danger"
    sh """
        curl -X POST -H 'Content-type: application/json' \
            --data '{"attachments":[{"color":"${color}","text":"[DB] ${message} | Build: ${env.BUILD_NUMBER}"}]}' \
            ${SLACK_WEBHOOK}
    """
}
