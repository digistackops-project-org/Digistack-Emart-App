// ============================================================
// Emart Login Service - Frontend Team Jenkins Pipeline
// CI/CD: Dev -> Staging -> Production
// Team: Frontend Team (React)
// ============================================================

pipeline {
    agent any

    environment {
        APP_NAME        = 'emart-login-frontend'
        DOCKER_REGISTRY = credentials('docker-registry-url')
        DOCKER_CREDS    = credentials('docker-registry-credentials')
        SLACK_WEBHOOK   = credentials('slack-webhook')
        KUBECONFIG_DEV  = credentials('kubeconfig-dev')
        KUBECONFIG_PROD = credentials('kubeconfig-prod')
    }

    parameters {
        choice(name: 'DEPLOY_ENV', choices: ['dev', 'staging', 'prod'])
        string(name: 'REACT_APP_API_URL', defaultValue: '', description: 'API URL override')
        booleanParam(name: 'RUN_E2E', defaultValue: false, description: 'Run E2E tests (Cypress)')
    }

    options {
        timeout(time: 30, unit: 'MINUTES')
        buildDiscarder(logRotator(numToKeepStr: '10'))
        timestamps()
    }

    stages {

        stage('Checkout') {
            steps {
                checkout scm
                script {
                    env.GIT_COMMIT_SHORT = sh(script: "git rev-parse --short HEAD", returnStdout: true).trim()
                    env.BUILD_TAG = "${env.BRANCH_NAME}-${env.GIT_COMMIT_SHORT}-${env.BUILD_NUMBER}"
                }
            }
        }

        stage('Install Dependencies') {
            steps {
                dir('frontend') {
                    sh '''
                        echo "=== [FRONTEND] Installing npm dependencies ==="
                        node --version
                        npm --version
                        npm ci --prefer-offline
                    '''
                }
            }
        }

        stage('Lint & Type Check') {
            steps {
                dir('frontend') {
                    sh '''
                        echo "=== [FRONTEND] Running ESLint ==="
                        npm run lint || true
                    '''
                }
            }
        }

        stage('Unit & Component Tests') {
            steps {
                dir('frontend') {
                    sh '''
                        echo "=== [FRONTEND] Running React Component Tests ==="
                        CI=true npm test -- --watchAll=false --coverage
                    '''
                }
            }
            post {
                always {
                    dir('frontend') {
                        publishHTML(target: [
                            allowMissing: false,
                            alwaysLinkToLastBuild: true,
                            keepAll: true,
                            reportDir: 'coverage/lcov-report',
                            reportFiles: 'index.html',
                            reportName: 'Frontend Coverage Report'
                        ])
                    }
                }
                failure {
                    script { notifySlack("FAILED", "Frontend unit tests FAILED on ${env.BRANCH_NAME}") }
                }
            }
        }

        stage('Build React App') {
            steps {
                dir('frontend') {
                    script {
                        def apiUrl = params.REACT_APP_API_URL ?: getApiUrlForEnv(params.DEPLOY_ENV)
                        sh """
                            echo "=== [FRONTEND] Building React production build ==="
                            REACT_APP_API_URL=${apiUrl} \
                            REACT_APP_VERSION=${env.BUILD_TAG} \
                            npm run build
                        """
                    }
                }
            }
        }

        stage('Build Docker Image') {
            steps {
                dir('frontend') {
                    sh """
                        docker build \
                            -t ${DOCKER_REGISTRY}/${APP_NAME}:${env.BUILD_TAG} \
                            -t ${DOCKER_REGISTRY}/${APP_NAME}:latest \
                            .
                    """
                }
            }
        }

        stage('Security Scan') {
            steps {
                sh """
                    trivy image \
                        --exit-code 1 \
                        --severity CRITICAL \
                        ${DOCKER_REGISTRY}/${APP_NAME}:${env.BUILD_TAG} || true
                """
            }
        }

        stage('Push to Registry') {
            steps {
                withCredentials([usernamePassword(
                    credentialsId: 'docker-registry-credentials',
                    usernameVariable: 'DOCKER_USER',
                    passwordVariable: 'DOCKER_PASS'
                )]) {
                    sh """
                        docker login ${DOCKER_REGISTRY} -u ${DOCKER_USER} -p ${DOCKER_PASS}
                        docker push ${DOCKER_REGISTRY}/${APP_NAME}:${env.BUILD_TAG}
                        docker push ${DOCKER_REGISTRY}/${APP_NAME}:latest
                    """
                }
            }
        }

        stage('Deploy to DEV') {
            when { branch 'develop' }
            environment { NAMESPACE = 'emart-dev'; REPLICAS = '1' }
            steps {
                sh """
                    export KUBECONFIG=${KUBECONFIG_DEV}
                    export IMAGE_TAG=${env.BUILD_TAG}
                    export DOMAIN=dev.emart.internal
                    envsubst < k8s/frontend/frontend-deployment.yaml | kubectl apply -f -
                    kubectl rollout status deployment/emart-login-frontend -n emart-dev --timeout=3m
                """
                script { notifySlack("SUCCESS", "Frontend deployed to DEV") }
            }
        }

        stage('Deploy to Staging') {
            when { branch 'main' }
            environment { NAMESPACE = 'emart-staging'; REPLICAS = '2' }
            steps {
                sh """
                    export KUBECONFIG=${KUBECONFIG_DEV}
                    export IMAGE_TAG=${env.BUILD_TAG}
                    export DOMAIN=staging.emart.internal
                    envsubst < k8s/frontend/frontend-deployment.yaml | kubectl apply -f -
                    kubectl rollout status deployment/emart-login-frontend -n emart-staging --timeout=3m
                """
                script { notifySlack("SUCCESS", "Frontend deployed to STAGING. Awaiting prod approval.") }
            }
        }

        stage('Production Approval') {
            when { branch 'main' }
            steps {
                timeout(time: 30, unit: 'MINUTES') {
                    input(
                        message: "Deploy Frontend to PRODUCTION?",
                        submitter: "frontend-lead,devops-team"
                    )
                }
            }
        }

        stage('Deploy to Production') {
            when { branch 'main' }
            environment { NAMESPACE = 'emart-prod'; REPLICAS = '3' }
            steps {
                sh """
                    export KUBECONFIG=${KUBECONFIG_PROD}
                    export IMAGE_TAG=${env.BUILD_TAG}
                    export DOMAIN=emart.com
                    envsubst < k8s/frontend/frontend-deployment.yaml | kubectl apply -f -
                    kubectl rollout status deployment/emart-login-frontend -n emart-prod --timeout=5m
                """
                script { notifySlack("SUCCESS", "Frontend PRODUCTION deployment successful!") }
            }
            post {
                failure {
                    sh """
                        export KUBECONFIG=${KUBECONFIG_PROD}
                        kubectl rollout undo deployment/emart-login-frontend -n emart-prod
                    """
                    script { notifySlack("FAILED", "FRONTEND PRODUCTION FAILED! Auto-rolled back!") }
                }
            }
        }
    }

    post { always { cleanWs() } }
}

def getApiUrlForEnv(String env) {
    switch(env) {
        case 'dev':     return 'http://dev.emart.internal/api/v1'
        case 'staging': return 'http://staging.emart.internal/api/v1'
        case 'prod':    return 'https://api.emart.com/api/v1'
        default:        return '/api/v1'
    }
}

def notifySlack(String status, String message) {
    def color = status == "SUCCESS" ? "good" : "danger"
    sh """
        curl -X POST -H 'Content-type: application/json' \
            --data '{"attachments":[{"color":"${color}","text":"[Frontend] ${message} | Build: ${env.BUILD_NUMBER}"}]}' \
            ${SLACK_WEBHOOK}
    """
}
